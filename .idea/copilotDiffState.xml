<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/JEDI-FLIPFLIT-JAVA-POS/src/main/java/com/flipfit/business/impl/FlipfitCustomerServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/JEDI-FLIPFLIT-JAVA-POS/src/main/java/com/flipfit/business/impl/FlipfitCustomerServiceImpl.java" />
              <option name="originalContent" value="package com.flipfit.business.impl;&#10;&#10;import com.flipfit.bean.*;&#10;import com.flipfit.dao.*;&#10;import com.flipfit.dao.impl.*;&#10;import com.flipfit.exception.DatabaseException;&#10;import com.flipfit.business.FlipfitCustomerService;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.stream.Collectors;&#10;import java.util.ArrayList;&#10;import java.util.Scanner;&#10;&#10;/**&#10; * Implementation of FlipfitCustomerService that uses MySQL DAO implementations&#10; */&#10;public class FlipfitCustomerServiceImpl implements FlipfitCustomerService {&#10;    private final FlipfitCardDAO cardDAO;&#10;    private final FlipfitCustomerDAO customerDAO;&#10;    private final FlipfitGymCenterDAO gymCenterDAO;&#10;    private final FlipfitSlotDAO slotDAO;&#10;    private final FlipfitBookingDAO bookingDAO;&#10;    private final FlipfitWaitlistDAO waitlistDAO;&#10;&#10;    public FlipfitCustomerServiceImpl() {&#10;        this.cardDAO = new FlipfitCardDAOImpl();&#10;        this.customerDAO = new FlipfitCustomerDAOImpl();&#10;        this.gymCenterDAO = new FlipfitGymCenterDAOImpl();&#10;        this.slotDAO = new FlipfitSlotDAOImpl();&#10;        this.bookingDAO = new FlipfitBookingDAOImpl();&#10;        this.waitlistDAO = new FlipfitWaitlistDAOImpl();&#10;    }&#10;&#10;    @Override&#10;    public boolean registerCustomer(FlipfitCustomer customer) {&#10;        try {&#10;            if (customer == null || customer.getEmail() == null || customer.getPassword() == null) {&#10;                System.out.println(&quot;Error: Invalid customer data provided&quot;);&#10;                return false;&#10;            }&#10;&#10;            // Check if email already exists&#10;            if (customerDAO.getCustomerByEmail(customer.getEmail()) != null) {&#10;                System.out.println(&quot;Error: A customer with this email already exists&quot;);&#10;                return false;&#10;            }&#10;&#10;            boolean result = customerDAO.addCustomer(customer);&#10;            if (result) {&#10;                System.out.println(&quot;Customer registered successfully with ID: &quot; + customer.getCustomerId());&#10;            } else {&#10;                System.out.println(&quot;Failed to register customer&quot;);&#10;            }&#10;            return result;&#10;        } catch (DatabaseException e) {&#10;            System.err.println(&quot;Database error during customer registration: &quot; + e.getMessage());&#10;            return false;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error during customer registration: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public FlipfitCustomer authenticateCustomer(String email, String password) {&#10;        try {&#10;            FlipfitCustomer customer = customerDAO.getCustomerByEmail(email);&#10;            if (customer != null &amp;&amp; customer.getPassword().equals(password)) {&#10;                return customer;&#10;            }&#10;            System.out.println(&quot;Invalid email or password&quot;);&#10;            return null;&#10;        } catch (DatabaseException e) {&#10;            System.err.println(&quot;Database error during authentication: &quot; + e.getMessage());&#10;            return null;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error during authentication: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitGymCenter&gt; viewAvailableGymCenters() {&#10;        try {&#10;            List&lt;FlipfitGymCenter&gt; centers = gymCenterDAO.getApprovedGymCenters();&#10;            if (centers.isEmpty()) {&#10;                System.out.println(&quot;No approved gym centers available at this time&quot;);&#10;            }&#10;            return centers;&#10;        } catch (DatabaseException e) {&#10;            System.err.println(&quot;Database error while retrieving gym centers: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error while retrieving gym centers: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitGymCenter&gt; viewGymCentersByLocation(String location) {&#10;        try {&#10;            if (location == null || location.trim().isEmpty()) {&#10;                System.out.println(&quot;Error: Location cannot be empty&quot;);&#10;                return new ArrayList&lt;&gt;();&#10;            }&#10;&#10;            List&lt;FlipfitGymCenter&gt; centers = gymCenterDAO.getGymCentersByLocation(location);&#10;            if (centers.isEmpty()) {&#10;                System.out.println(&quot;No gym centers found at location: &quot; + location);&#10;            }&#10;            return centers;&#10;        } catch (DatabaseException e) {&#10;            System.err.println(&quot;Database error while retrieving gym centers by location: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error while retrieving gym centers by location: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitSlot&gt; viewAvailableSlots(int centerId, String day) {&#10;        try {&#10;            if (centerId &lt;= 0) {&#10;                System.out.println(&quot;Error: Invalid center ID&quot;);&#10;                return new ArrayList&lt;&gt;();&#10;            }&#10;&#10;            if (day == null || day.trim().isEmpty()) {&#10;                System.out.println(&quot;Error: Day cannot be empty&quot;);&#10;                return new ArrayList&lt;&gt;();&#10;            }&#10;&#10;            List&lt;FlipfitSlot&gt; slots = slotDAO.getAvailableSlotsByCenterAndDay(centerId, day);&#10;            if (slots.isEmpty()) {&#10;                System.out.println(&quot;No available slots for center ID &quot; + centerId + &quot; on &quot; + day);&#10;            }&#10;            return slots;&#10;        } catch (DatabaseException e) {&#10;            System.err.println(&quot;Database error while retrieving available slots: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error while retrieving available slots: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public FlipfitBooking bookSlot(int customerId, int slotId, LocalDate bookingDate) {&#10;        // Validate booking date constraints&#10;        if (!isValidBookingDate(bookingDate)) {&#10;            return null; // Don't add to waitlist for invalid dates&#10;        }&#10;&#10;        // Get slot information to validate weekday and fetch center ID&#10;        FlipfitSlot slot = slotDAO.getSlotById(slotId);&#10;        if (slot == null) {&#10;            System.out.println(&quot;Slot doesn't exist.&quot;);&#10;            return null;&#10;        }&#10;&#10;        // Validate that booking date matches the slot's weekday&#10;        if (!isCorrectWeekday(bookingDate, slot.getDay())) {&#10;            System.out.println(&quot;Booking date &quot; + bookingDate + &quot; doesn't match slot day &quot; + slot.getDay() + &quot;. Please choose a correct date.&quot;);&#10;            return null; // Don't add to waitlist for wrong weekday&#10;        }&#10;&#10;        // Check for overlapping bookings on the same date&#10;        List&lt;FlipfitBooking&gt; existingBookings = getCustomerBookingsForDate(customerId, bookingDate);&#10;        if (!existingBookings.isEmpty()) {&#10;            if (!handleOverlappingBookings(existingBookings, slot)) {&#10;                return null; // User explicitly cancelled, don't add to waitlist&#10;            }&#10;        }&#10;&#10;        // Check if slot is full, if so add to waitlist&#10;        if (slot.getAvailableSeats() &lt;= 0) {&#10;            System.out.println(&quot;Slot is full. You have been added to the waitlist.&quot;);&#10;            return addToWaitlist(customerId, slotId, bookingDate);&#10;        }&#10;&#10;        if (!slot.isAvailable()) {&#10;            System.out.println(&quot;Slot not available.&quot;);&#10;            return null;&#10;        }&#10;&#10;        List&lt;FlipfitCard&gt; cards = cardDAO.getCustomerCards(customerId);&#10;        if (cards.isEmpty()) {&#10;            System.out.println(&quot;No payment methods found. Please add a card first.&quot;);&#10;            return null;&#10;        }&#10;&#10;        // Display available cards&#10;        System.out.println(&quot;\nSelect a card for payment:&quot;);&#10;        for (FlipfitCard card : cards) {&#10;            System.out.println(card.getCardId() + &quot;. Card ending in &quot; +&#10;                    card.getCardNumber().substring(card.getCardNumber().length() - 4));&#10;        }&#10;&#10;        Scanner scanner = new Scanner(System.in);&#10;        System.out.print(&quot;Enter card ID to use for payment: &quot;);&#10;        int selectedCardId = scanner.nextInt();&#10;&#10;        // Validate selected card&#10;        boolean cardFound = false;&#10;        for (FlipfitCard card : cards) {&#10;            if (card.getCardId() == selectedCardId) {&#10;                cardFound = true;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (!cardFound) {&#10;            System.out.println(&quot;Invalid card selected.&quot;);&#10;            return null;&#10;        }&#10;&#10;        FlipfitCustomer customer = customerDAO.getCustomerById(customerId);&#10;        if (customer == null) {&#10;            return null;&#10;        }&#10;&#10;        // Create booking with payment using slot's dynamic price&#10;        FlipfitBooking booking = new FlipfitBooking();&#10;        booking.setCustomerId(customerId);&#10;        booking.setSlotId(slotId);&#10;        booking.setCenterId(slot.getCenterId()); // Set the center ID from slot&#10;        booking.setBookingDate(bookingDate);&#10;        booking.setAmount(slot.getPrice()); // Use slot's dynamic price&#10;        booking.setStatus(FlipfitBooking.BookingStatus.CONFIRMED); // Set initial status&#10;        booking.setBookingTime(LocalDateTime.now());&#10;&#10;        System.out.println(&quot;\nConfirm payment of ₹&quot; + slot.getPrice());&#10;        System.out.print(&quot;Enter 1 to confirm payment, 0 to cancel: &quot;);&#10;        int confirm = scanner.nextInt();&#10;&#10;        if (confirm != 1) {&#10;            System.out.println(&quot;Payment cancelled.&quot;);&#10;            return null;&#10;        }&#10;&#10;        if (bookingDAO.addBooking(booking)) {&#10;            // Update slot availability&#10;            int newAvailableSeats = slot.getAvailableSeats() - 1;&#10;            slotDAO.updateSlotAvailability(slotId, newAvailableSeats);&#10;            System.out.println(&quot;Payment successful!&quot;);&#10;            return booking;&#10;        } else {&#10;            System.out.println(&quot;Booking failed. Please try again.&quot;);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private boolean isValidBookingDate(LocalDate bookingDate) {&#10;        LocalDate today = LocalDate.now();&#10;        LocalDate tomorrow = today.plusDays(1);&#10;        LocalDate maxBookingDate = today.plusWeeks(1);&#10;&#10;        if (bookingDate.isBefore(tomorrow)) {&#10;            System.out.println(&quot;Cannot book for today or past dates. Please select from tomorrow onwards.&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (bookingDate.isAfter(maxBookingDate)) {&#10;            System.out.println(&quot;Cannot book more than 1 week in advance. Maximum booking date: &quot; + maxBookingDate);&#10;            return false;&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    private boolean isCorrectWeekday(LocalDate bookingDate, String slotDay) {&#10;        String bookingDayOfWeek = bookingDate.getDayOfWeek().name();&#10;&#10;        // Convert to proper case for comparison&#10;        String bookingDay = bookingDayOfWeek.charAt(0) + bookingDayOfWeek.substring(1).toLowerCase();&#10;&#10;        return bookingDay.equalsIgnoreCase(slotDay);&#10;    }&#10;&#10;    private List&lt;FlipfitBooking&gt; getCustomerBookingsForDate(int customerId, LocalDate date) {&#10;        List&lt;FlipfitBooking&gt; allBookings = bookingDAO.getBookingsByCustomerId(customerId);&#10;        return allBookings.stream()&#10;                .filter(booking -&gt; booking.getBookingDate().equals(date) &amp;&amp;&#10;                        (booking.getStatus() == FlipfitBooking.BookingStatus.CONFIRMED ||&#10;                         booking.getStatus() == FlipfitBooking.BookingStatus.PENDING))&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    private boolean handleOverlappingBookings(List&lt;FlipfitBooking&gt; existingBookings, FlipfitSlot newSlot) {&#10;        System.out.println(&quot;\nWarning: You already have bookings on this date:&quot;);&#10;&#10;        for (FlipfitBooking booking : existingBookings) {&#10;            FlipfitSlot existingSlot = slotDAO.getSlotById(booking.getSlotId());&#10;            if (existingSlot != null) {&#10;                System.out.println(&quot;Booking ID: &quot; + booking.getBookingId() +&#10;                                 &quot; | Time: &quot; + existingSlot.getStartTime() + &quot; - &quot; + existingSlot.getEndTime() +&#10;                                 &quot; | Status: &quot; + booking.getStatus());&#10;&#10;                // Check for time overlap&#10;                if (slotsOverlap(existingSlot, newSlot)) {&#10;                    System.out.println(&quot;Time slots overlap detected!&quot;);&#10;                    System.out.println(&quot;Existing slot: &quot; + existingSlot.getStartTime() + &quot; - &quot; + existingSlot.getEndTime());&#10;                    System.out.println(&quot;New slot: &quot; + newSlot.getStartTime() + &quot; - &quot; + newSlot.getEndTime());&#10;&#10;                    Scanner scanner = new Scanner(System.in);&#10;                    System.out.println(&quot;\nChoose an option:&quot;);&#10;                    System.out.println(&quot;1. Cancel existing overlapping bookings and proceed with new booking&quot;);&#10;                    System.out.println(&quot;2. Keep both bookings (allow overlapping)&quot;);&#10;                    System.out.println(&quot;3. Cancel new booking&quot;);&#10;                    System.out.print(&quot;Enter your choice (1-3): &quot;);&#10;&#10;                    int choice = scanner.nextInt();&#10;                    switch (choice) {&#10;                        case 1:&#10;                            // Cancel overlapping bookings&#10;                            for (FlipfitBooking overlappingBooking : existingBookings) {&#10;                                FlipfitSlot overlappingSlot = slotDAO.getSlotById(overlappingBooking.getSlotId());&#10;                                if (overlappingSlot != null &amp;&amp; slotsOverlap(overlappingSlot, newSlot)) {&#10;                                    cancelBooking(overlappingBooking.getBookingId(), overlappingBooking.getCustomerId());&#10;                                    System.out.println(&quot;Cancelled overlapping booking ID: &quot; + overlappingBooking.getBookingId());&#10;                                }&#10;                            }&#10;                            return true;&#10;                        case 2:&#10;                            System.out.println(&quot;Proceeding with overlapping bookings...&quot;);&#10;                            return true;&#10;                        case 3:&#10;                            System.out.println(&quot;New booking cancelled.&quot;);&#10;                            return false;&#10;                        default:&#10;                            System.out.println(&quot;Invalid choice. Cancelling new booking.&quot;);&#10;                            return false;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // No overlaps found, but existing bookings on same date&#10;        Scanner scanner = new Scanner(System.in);&#10;        System.out.println(&quot;\nYou have existing bookings on this date but no time conflicts.&quot;);&#10;        System.out.print(&quot;Do you want to proceed with the new booking? (1 for Yes, 0 for No): &quot;);&#10;        int proceed = scanner.nextInt();&#10;&#10;        return proceed == 1;&#10;    }&#10;&#10;    private boolean slotsOverlap(FlipfitSlot slot1, FlipfitSlot slot2) {&#10;        return slot1.getStartTime().isBefore(slot2.getEndTime()) &amp;&amp;&#10;               slot2.getStartTime().isBefore(slot1.getEndTime());&#10;    }&#10;&#10;    @Override&#10;    public boolean cancelBooking(int bookingId, int customerId) {&#10;        FlipfitBooking booking = bookingDAO.getBookingById(bookingId);&#10;        if (booking == null || booking.getCustomerId() != customerId) {&#10;            return false;&#10;        }&#10;&#10;        if (booking.getStatus() == FlipfitBooking.BookingStatus.CANCELLED) {&#10;            return false;&#10;        }&#10;&#10;        // Cancel the original booking&#10;        booking.setStatus(FlipfitBooking.BookingStatus.CANCELLED);&#10;        bookingDAO.updateBooking(booking);&#10;&#10;        // Increase slot availability and check for waitlist&#10;        FlipfitSlot slot = slotDAO.getSlotById(booking.getSlotId());&#10;        if (slot != null) {&#10;            slot.setAvailableSeats(slot.getAvailableSeats() + 1);&#10;            slotDAO.updateSlot(slot);&#10;&#10;            // Promote customer from waitlist if slot is now available&#10;            FlipfitWaitlist waitlist = waitlistDAO.getWaitlistBySlotId(slot.getSlotId());&#10;            if (waitlist != null &amp;&amp; !waitlist.getCustomerIds().isEmpty()) {&#10;                Integer nextCustomerId = waitlist.getNextCustomer();&#10;                if (nextCustomerId != null) {&#10;                    System.out.println(&quot;Promoting customer &quot; + nextCustomerId + &quot; from waitlist for slot &quot; + slot.getSlotId());&#10;&#10;                    // Find the existing waitlisted booking for this customer&#10;                    FlipfitBooking waitlistBooking = bookingDAO.getBookingsByCustomerId(nextCustomerId)&#10;                            .stream()&#10;                            .filter(b -&gt; b.getSlotId() == slot.getSlotId() &amp;&amp; b.getStatus() == FlipfitBooking.BookingStatus.WAITLISTED)&#10;                            .findFirst()&#10;                            .orElse(null);&#10;&#10;                    if (waitlistBooking != null) {&#10;                        // Change the status of the existing booking to CONFIRMED&#10;                        waitlistBooking.setStatus(FlipfitBooking.BookingStatus.CONFIRMED);&#10;                        bookingDAO.updateBooking(waitlistBooking);&#10;&#10;                        // Update slot availability again for the new confirmed booking&#10;                        slot.setAvailableSeats(slot.getAvailableSeats() - 1);&#10;                        slotDAO.updateSlot(slot);&#10;&#10;                        waitlistDAO.updateWaitlist(waitlist);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;&#10;&#10;&#10;//    @Override&#10;//    public int addToWaitlist(int customerId, int slotId) {&#10;//        FlipfitWaitlist waitlist = waitlistDAO.getWaitlistBySlotId(slotId);&#10;//        if (waitlist == null) {&#10;//            waitlist = new FlipfitWaitlist();&#10;//            waitlist.setSlotId(slotId);&#10;//            waitlistDAO.addWaitlist(waitlist);&#10;//        }&#10;//&#10;//        if (waitlist.getCustomerIds().contains(customerId)) {&#10;//            return waitlist.getCustomerIds().size();&#10;//        }&#10;//&#10;//        waitlist.getCustomerIds().add(customerId);&#10;//        waitlistDAO.updateWaitlist(waitlist);&#10;//        return waitlist.getCustomerIds().size();&#10;//    }&#10;&#10;    @Override&#10;    public FlipfitBooking addToWaitlist(int customerId, int slotId, LocalDate bookingDate) {&#10;        FlipfitWaitlist waitlist = waitlistDAO.getWaitlistBySlotId(slotId);&#10;        FlipfitSlot slot = slotDAO.getSlotById(slotId);&#10;&#10;        if (slot == null) {&#10;            return null;&#10;        }&#10;&#10;        if (waitlist == null) {&#10;            waitlist = new FlipfitWaitlist();&#10;            waitlist.setSlotId(slotId);&#10;            waitlistDAO.addWaitlist(waitlist);&#10;        }&#10;&#10;        if (waitlist.getCustomerIds().contains(customerId)) {&#10;            System.out.println(&quot;You are already on the waitlist for this slot.&quot;);&#10;            return null;&#10;        }&#10;&#10;        waitlist.getCustomerIds().add(customerId);&#10;        waitlistDAO.updateWaitlist(waitlist);&#10;&#10;        FlipfitBooking waitlistBooking = new FlipfitBooking(0, customerId, slotId, slot.getCenterId(), bookingDate, slot.getPrice());&#10;        waitlistBooking.setStatus(FlipfitBooking.BookingStatus.WAITLISTED);&#10;        bookingDAO.addBooking(waitlistBooking);&#10;&#10;        return waitlistBooking;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitBooking&gt; viewBookings(int customerId) {&#10;        return bookingDAO.getBookingsByCustomerId(customerId);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitBooking&gt; viewBookingsByDate(int customerId, LocalDate date) {&#10;        return bookingDAO.getBookingsByCustomerId(customerId).stream()&#10;                .filter(booking -&gt; booking.getBookingDate().equals(date))&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    @Override&#10;    public FlipfitCustomer getCustomerProfile(int customerId) {&#10;        return customerDAO.getCustomerById(customerId);&#10;    }&#10;&#10;    @Override&#10;    public boolean updateCustomerProfile(FlipfitCustomer customer) {&#10;        return customerDAO.updateCustomer(customer);&#10;    }&#10;&#10;    @Override&#10;    public boolean addCard(FlipfitCard card) {&#10;        return cardDAO.addCard(card);&#10;    }&#10;&#10;    @Override&#10;    public boolean removeCard(int cardId, int customerId) {&#10;        return cardDAO.removeCard(cardId, customerId);&#10;    }&#10;&#10;    @Override&#10;    public boolean updateCard(FlipfitCard card) {&#10;        return cardDAO.updateCard(card);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitCard&gt; getCustomerCards(int customerId) {&#10;        return cardDAO.getCustomerCards(customerId);&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.flipfit.business.impl;&#10;&#10;import com.flipfit.bean.*;&#10;import com.flipfit.dao.*;&#10;import com.flipfit.dao.impl.*;&#10;import com.flipfit.exception.*;&#10;import com.flipfit.business.FlipfitCustomerService;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.stream.Collectors;&#10;import java.util.ArrayList;&#10;import java.util.Scanner;&#10;&#10;/**&#10; * Implementation of FlipfitCustomerService that uses MySQL DAO implementations&#10; */&#10;public class FlipfitCustomerServiceImpl implements FlipfitCustomerService {&#10;    private final FlipfitCardDAO cardDAO;&#10;    private final FlipfitCustomerDAO customerDAO;&#10;    private final FlipfitGymCenterDAO gymCenterDAO;&#10;    private final FlipfitSlotDAO slotDAO;&#10;    private final FlipfitBookingDAO bookingDAO;&#10;    private final FlipfitWaitlistDAO waitlistDAO;&#10;&#10;    public FlipfitCustomerServiceImpl() {&#10;        this.cardDAO = new FlipfitCardDAOImpl();&#10;        this.customerDAO = new FlipfitCustomerDAOImpl();&#10;        this.gymCenterDAO = new FlipfitGymCenterDAOImpl();&#10;        this.slotDAO = new FlipfitSlotDAOImpl();&#10;        this.bookingDAO = new FlipfitBookingDAOImpl();&#10;        this.waitlistDAO = new FlipfitWaitlistDAOImpl();&#10;    }&#10;&#10;    @Override&#10;    public boolean registerCustomer(FlipfitCustomer customer) {&#10;        try {&#10;            if (customer == null || customer.getEmail() == null || customer.getPassword() == null) {&#10;                throw new RegistrationNotDoneException(&quot;Invalid customer data provided&quot;);&#10;            }&#10;&#10;            // Check if email already exists&#10;            if (customerDAO.getCustomerByEmail(customer.getEmail()) != null) {&#10;                throw new RegistrationNotDoneException(&quot;A customer with email &quot; + customer.getEmail() + &quot; already exists&quot;);&#10;            }&#10;&#10;            boolean result = customerDAO.addCustomer(customer);&#10;            if (result) {&#10;                System.out.println(&quot;Customer registered successfully with ID: &quot; + customer.getCustomerId());&#10;            } else {&#10;                throw new RegistrationNotDoneException(&quot;Failed to register customer in the database&quot;);&#10;            }&#10;            return result;&#10;        } catch (RegistrationNotDoneException e) {&#10;            String errorMessage = ExceptionHandler.handleException(e);&#10;            System.err.println(errorMessage);&#10;            return false;&#10;        } catch (DatabaseException e) {&#10;            String errorMessage = ExceptionHandler.handleException(e);&#10;            System.err.println(errorMessage);&#10;            return false;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error during customer registration: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public FlipfitCustomer authenticateCustomer(String email, String password) {&#10;        try {&#10;            FlipfitCustomer customer = customerDAO.getCustomerByEmail(email);&#10;            if (customer == null) {&#10;                throw new UserNotFoundException(&quot;Customer with email &quot; + email + &quot; not found&quot;);&#10;            }&#10;            &#10;            if (!customer.getPassword().equals(password)) {&#10;                System.out.println(&quot;Invalid password&quot;);&#10;                return null;&#10;            }&#10;            &#10;            return customer;&#10;        } catch (UserNotFoundException e) {&#10;            String errorMessage = ExceptionHandler.handleException(e);&#10;            System.err.println(errorMessage);&#10;            return null;&#10;        } catch (DatabaseException e) {&#10;            String errorMessage = ExceptionHandler.handleException(e);&#10;            System.err.println(errorMessage);&#10;            return null;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error during authentication: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitGymCenter&gt; viewAvailableGymCenters() {&#10;        try {&#10;            List&lt;FlipfitGymCenter&gt; centers = gymCenterDAO.getApprovedGymCenters();&#10;            if (centers.isEmpty()) {&#10;                System.out.println(&quot;No approved gym centers available at this time&quot;);&#10;            }&#10;            return centers;&#10;        } catch (DatabaseException e) {&#10;            System.err.println(&quot;Database error while retrieving gym centers: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error while retrieving gym centers: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitGymCenter&gt; viewGymCentersByLocation(String location) {&#10;        try {&#10;            if (location == null || location.trim().isEmpty()) {&#10;                System.out.println(&quot;Error: Location cannot be empty&quot;);&#10;                return new ArrayList&lt;&gt;();&#10;            }&#10;&#10;            List&lt;FlipfitGymCenter&gt; centers = gymCenterDAO.getGymCentersByLocation(location);&#10;            if (centers.isEmpty()) {&#10;                System.out.println(&quot;No gym centers found at location: &quot; + location);&#10;            }&#10;            return centers;&#10;        } catch (DatabaseException e) {&#10;            System.err.println(&quot;Database error while retrieving gym centers by location: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error while retrieving gym centers by location: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitSlot&gt; viewAvailableSlots(int centerId, String day) {&#10;        try {&#10;            if (centerId &lt;= 0) {&#10;                System.out.println(&quot;Error: Invalid center ID&quot;);&#10;                return new ArrayList&lt;&gt;();&#10;            }&#10;&#10;            if (day == null || day.trim().isEmpty()) {&#10;                System.out.println(&quot;Error: Day cannot be empty&quot;);&#10;                return new ArrayList&lt;&gt;();&#10;            }&#10;&#10;            List&lt;FlipfitSlot&gt; slots = slotDAO.getAvailableSlotsByCenterAndDay(centerId, day);&#10;            if (slots.isEmpty()) {&#10;                System.out.println(&quot;No available slots for center ID &quot; + centerId + &quot; on &quot; + day);&#10;            }&#10;            return slots;&#10;        } catch (DatabaseException e) {&#10;            System.err.println(&quot;Database error while retrieving available slots: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error while retrieving available slots: &quot; + e.getMessage());&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public FlipfitBooking bookSlot(int customerId, int slotId, LocalDate bookingDate) {&#10;        try {&#10;            // Validate booking date constraints&#10;            if (!isValidBookingDate(bookingDate)) {&#10;                throw new BookingNotConfirmedException(&quot;Invalid booking date. Please choose a date between tomorrow and 1 week from now.&quot;);&#10;            }&#10;&#10;            // Get slot information to validate weekday and fetch center ID&#10;            FlipfitSlot slot = slotDAO.getSlotById(slotId);&#10;            if (slot == null) {&#10;                throw new SlotNotFoundException(String.valueOf(slotId), &quot;N/A&quot;);&#10;            }&#10;&#10;            // Validate that booking date matches the slot's weekday&#10;            if (!isCorrectWeekday(bookingDate, slot.getDay())) {&#10;                throw new SlotNotFoundException(&quot;Booking date &quot; + bookingDate + &quot; doesn't match slot day &quot; + slot.getDay() + &quot;. Please choose a correct date.&quot;);&#10;            }&#10;&#10;            // Check for overlapping bookings on the same date&#10;            List&lt;FlipfitBooking&gt; existingBookings = getCustomerBookingsForDate(customerId, bookingDate);&#10;            if (!existingBookings.isEmpty()) {&#10;                if (!handleOverlappingBookings(existingBookings, slot)) {&#10;                    return null; // User explicitly cancelled, don't add to waitlist&#10;                }&#10;            }&#10;&#10;            // Check if slot is full, if so add to waitlist&#10;            if (slot.getAvailableSeats() &lt;= 0) {&#10;                System.out.println(&quot;Slot is full. You have been added to the waitlist.&quot;);&#10;                return addToWaitlist(customerId, slotId, bookingDate);&#10;            }&#10;&#10;            if (!slot.isAvailable()) {&#10;                throw new SlotNotFoundException(&quot;Slot is not available for booking&quot;);&#10;            }&#10;&#10;            List&lt;FlipfitCard&gt; cards = cardDAO.getCustomerCards(customerId);&#10;            if (cards.isEmpty()) {&#10;                throw new PaymentNotDoneException(&quot;No payment methods found. Please add a card first.&quot;);&#10;            }&#10;&#10;            // Display available cards&#10;            System.out.println(&quot;\nSelect a card for payment:&quot;);&#10;            for (FlipfitCard card : cards) {&#10;                System.out.println(card.getCardId() + &quot;. Card ending in &quot; +&#10;                        card.getCardNumber().substring(card.getCardNumber().length() - 4));&#10;            }&#10;&#10;            Scanner scanner = new Scanner(System.in);&#10;            System.out.print(&quot;Enter card ID to use for payment: &quot;);&#10;            int selectedCardId = scanner.nextInt();&#10;&#10;            // Validate selected card&#10;            boolean cardFound = false;&#10;            for (FlipfitCard card : cards) {&#10;                if (card.getCardId() == selectedCardId) {&#10;                    cardFound = true;&#10;                    break;&#10;                }&#10;            }&#10;&#10;            if (!cardFound) {&#10;                throw new PaymentNotDoneException(&quot;Invalid card selected.&quot;);&#10;            }&#10;&#10;            FlipfitCustomer customer = customerDAO.getCustomerById(customerId);&#10;            if (customer == null) {&#10;                throw new UserNotFoundException(String.valueOf(customerId), &quot;Customer&quot;);&#10;            }&#10;&#10;            // Create booking with payment using slot's dynamic price&#10;            FlipfitBooking booking = new FlipfitBooking();&#10;            booking.setCustomerId(customerId);&#10;            booking.setSlotId(slotId);&#10;            booking.setCenterId(slot.getCenterId()); // Set the center ID from slot&#10;            booking.setBookingDate(bookingDate);&#10;            booking.setAmount(slot.getPrice()); // Use slot's dynamic price&#10;            booking.setStatus(FlipfitBooking.BookingStatus.CONFIRMED); // Set initial status&#10;            booking.setBookingTime(LocalDateTime.now());&#10;&#10;            System.out.println(&quot;\nConfirm payment of ₹&quot; + slot.getPrice());&#10;            System.out.print(&quot;Enter 1 to confirm payment, 0 to cancel: &quot;);&#10;            int confirm = scanner.nextInt();&#10;&#10;            if (confirm != 1) {&#10;                throw new PaymentNotDoneException(&quot;Payment cancelled by user.&quot;);&#10;            }&#10;&#10;            if (bookingDAO.addBooking(booking)) {&#10;                // Update slot availability&#10;                int newAvailableSeats = slot.getAvailableSeats() - 1;&#10;                slotDAO.updateSlotAvailability(slotId, newAvailableSeats);&#10;                System.out.println(&quot;Payment successful!&quot;);&#10;                return booking;&#10;            } else {&#10;                throw new BookingNotConfirmedException(&quot;Booking could not be confirmed. Please try again.&quot;);&#10;            }&#10;        } catch (SlotNotFoundException | UserNotFoundException | PaymentNotDoneException | BookingNotConfirmedException e) {&#10;            String errorMessage = ExceptionHandler.handleException(e);&#10;            System.err.println(errorMessage);&#10;            return null;&#10;        } catch (DatabaseException e) {&#10;            String errorMessage = ExceptionHandler.handleException(e);&#10;            System.err.println(errorMessage);&#10;            return null;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error during slot booking: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private boolean isValidBookingDate(LocalDate bookingDate) {&#10;        LocalDate today = LocalDate.now();&#10;        LocalDate tomorrow = today.plusDays(1);&#10;        LocalDate maxBookingDate = today.plusWeeks(1);&#10;&#10;        if (bookingDate.isBefore(tomorrow)) {&#10;            System.out.println(&quot;Cannot book for today or past dates. Please select from tomorrow onwards.&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (bookingDate.isAfter(maxBookingDate)) {&#10;            System.out.println(&quot;Cannot book more than 1 week in advance. Maximum booking date: &quot; + maxBookingDate);&#10;            return false;&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    private boolean isCorrectWeekday(LocalDate bookingDate, String slotDay) {&#10;        String bookingDayOfWeek = bookingDate.getDayOfWeek().name();&#10;&#10;        // Convert to proper case for comparison&#10;        String bookingDay = bookingDayOfWeek.charAt(0) + bookingDayOfWeek.substring(1).toLowerCase();&#10;&#10;        return bookingDay.equalsIgnoreCase(slotDay);&#10;    }&#10;&#10;    private List&lt;FlipfitBooking&gt; getCustomerBookingsForDate(int customerId, LocalDate date) {&#10;        List&lt;FlipfitBooking&gt; allBookings = bookingDAO.getBookingsByCustomerId(customerId);&#10;        return allBookings.stream()&#10;                .filter(booking -&gt; booking.getBookingDate().equals(date) &amp;&amp;&#10;                        (booking.getStatus() == FlipfitBooking.BookingStatus.CONFIRMED ||&#10;                         booking.getStatus() == FlipfitBooking.BookingStatus.PENDING))&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    private boolean handleOverlappingBookings(List&lt;FlipfitBooking&gt; existingBookings, FlipfitSlot newSlot) {&#10;        System.out.println(&quot;\nWarning: You already have bookings on this date:&quot;);&#10;&#10;        for (FlipfitBooking booking : existingBookings) {&#10;            FlipfitSlot existingSlot = slotDAO.getSlotById(booking.getSlotId());&#10;            if (existingSlot != null) {&#10;                System.out.println(&quot;Booking ID: &quot; + booking.getBookingId() +&#10;                                 &quot; | Time: &quot; + existingSlot.getStartTime() + &quot; - &quot; + existingSlot.getEndTime() +&#10;                                 &quot; | Status: &quot; + booking.getStatus());&#10;&#10;                // Check for time overlap&#10;                if (slotsOverlap(existingSlot, newSlot)) {&#10;                    System.out.println(&quot;Time slots overlap detected!&quot;);&#10;                    System.out.println(&quot;Existing slot: &quot; + existingSlot.getStartTime() + &quot; - &quot; + existingSlot.getEndTime());&#10;                    System.out.println(&quot;New slot: &quot; + newSlot.getStartTime() + &quot; - &quot; + newSlot.getEndTime());&#10;&#10;                    Scanner scanner = new Scanner(System.in);&#10;                    System.out.println(&quot;\nChoose an option:&quot;);&#10;                    System.out.println(&quot;1. Cancel existing overlapping bookings and proceed with new booking&quot;);&#10;                    System.out.println(&quot;2. Keep both bookings (allow overlapping)&quot;);&#10;                    System.out.println(&quot;3. Cancel new booking&quot;);&#10;                    System.out.print(&quot;Enter your choice (1-3): &quot;);&#10;&#10;                    int choice = scanner.nextInt();&#10;                    switch (choice) {&#10;                        case 1:&#10;                            // Cancel overlapping bookings&#10;                            for (FlipfitBooking overlappingBooking : existingBookings) {&#10;                                FlipfitSlot overlappingSlot = slotDAO.getSlotById(overlappingBooking.getSlotId());&#10;                                if (overlappingSlot != null &amp;&amp; slotsOverlap(overlappingSlot, newSlot)) {&#10;                                    cancelBooking(overlappingBooking.getBookingId(), overlappingBooking.getCustomerId());&#10;                                    System.out.println(&quot;Cancelled overlapping booking ID: &quot; + overlappingBooking.getBookingId());&#10;                                }&#10;                            }&#10;                            return true;&#10;                        case 2:&#10;                            System.out.println(&quot;Proceeding with overlapping bookings...&quot;);&#10;                            return true;&#10;                        case 3:&#10;                            System.out.println(&quot;New booking cancelled.&quot;);&#10;                            return false;&#10;                        default:&#10;                            System.out.println(&quot;Invalid choice. Cancelling new booking.&quot;);&#10;                            return false;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // No overlaps found, but existing bookings on same date&#10;        Scanner scanner = new Scanner(System.in);&#10;        System.out.println(&quot;\nYou have existing bookings on this date but no time conflicts.&quot;);&#10;        System.out.print(&quot;Do you want to proceed with the new booking? (1 for Yes, 0 for No): &quot;);&#10;        int proceed = scanner.nextInt();&#10;&#10;        return proceed == 1;&#10;    }&#10;&#10;    private boolean slotsOverlap(FlipfitSlot slot1, FlipfitSlot slot2) {&#10;        return slot1.getStartTime().isBefore(slot2.getEndTime()) &amp;&amp;&#10;               slot2.getStartTime().isBefore(slot1.getEndTime());&#10;    }&#10;&#10;    @Override&#10;    public boolean cancelBooking(int bookingId, int customerId) {&#10;        try {&#10;            FlipfitBooking booking = bookingDAO.getBookingById(bookingId);&#10;            if (booking == null) {&#10;                throw new BookingNotConfirmedException(&quot;Booking with ID &quot; + bookingId + &quot; not found&quot;);&#10;            }&#10;            &#10;            if (booking.getCustomerId() != customerId) {&#10;                throw new UserNotFoundException(&quot;Customer &quot; + customerId + &quot; is not authorized to cancel this booking&quot;);&#10;            }&#10;&#10;            if (booking.getStatus() == FlipfitBooking.BookingStatus.CANCELLED) {&#10;                throw new BookingNotConfirmedException(&quot;Booking is already cancelled&quot;);&#10;            }&#10;&#10;            // Cancel the original booking&#10;            booking.setStatus(FlipfitBooking.BookingStatus.CANCELLED);&#10;            boolean updateSuccess = bookingDAO.updateBooking(booking);&#10;            &#10;            if (!updateSuccess) {&#10;                throw new DatabaseException(&quot;Failed to update booking status to cancelled&quot;);&#10;            }&#10;&#10;            // Increase slot availability and check for waitlist&#10;            FlipfitSlot slot = slotDAO.getSlotById(booking.getSlotId());&#10;            if (slot == null) {&#10;                throw new SlotNotFoundException(String.valueOf(booking.getSlotId()), String.valueOf(booking.getCenterId()));&#10;            }&#10;            &#10;            slot.setAvailableSeats(slot.getAvailableSeats() + 1);&#10;            slotDAO.updateSlot(slot);&#10;&#10;            // Promote customer from waitlist if slot is now available&#10;            FlipfitWaitlist waitlist = waitlistDAO.getWaitlistBySlotId(slot.getSlotId());&#10;            if (waitlist != null &amp;&amp; !waitlist.getCustomerIds().isEmpty()) {&#10;                Integer nextCustomerId = waitlist.getNextCustomer();&#10;                if (nextCustomerId != null) {&#10;                    System.out.println(&quot;Promoting customer &quot; + nextCustomerId + &quot; from waitlist for slot &quot; + slot.getSlotId());&#10;&#10;                    // Find the existing waitlisted booking for this customer&#10;                    FlipfitBooking waitlistBooking = bookingDAO.getBookingsByCustomerId(nextCustomerId)&#10;                            .stream()&#10;                            .filter(b -&gt; b.getSlotId() == slot.getSlotId() &amp;&amp; b.getStatus() == FlipfitBooking.BookingStatus.WAITLISTED)&#10;                            .findFirst()&#10;                            .orElse(null);&#10;&#10;                    if (waitlistBooking != null) {&#10;                        // Change the status of the existing booking to CONFIRMED&#10;                        waitlistBooking.setStatus(FlipfitBooking.BookingStatus.CONFIRMED);&#10;                        bookingDAO.updateBooking(waitlistBooking);&#10;&#10;                        // Update slot availability again for the new confirmed booking&#10;                        slot.setAvailableSeats(slot.getAvailableSeats() - 1);&#10;                        slotDAO.updateSlot(slot);&#10;&#10;                        waitlistDAO.updateWaitlist(waitlist);&#10;                    }&#10;                }&#10;            }&#10;            return true;&#10;        } catch (BookingNotConfirmedException | UserNotFoundException | SlotNotFoundException | DatabaseException e) {&#10;            String errorMessage = ExceptionHandler.handleException(e);&#10;            System.err.println(errorMessage);&#10;            return false;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error during booking cancellation: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;&#10;&#10;&#10;//    @Override&#10;//    public int addToWaitlist(int customerId, int slotId) {&#10;//        FlipfitWaitlist waitlist = waitlistDAO.getWaitlistBySlotId(slotId);&#10;//        if (waitlist == null) {&#10;//            waitlist = new FlipfitWaitlist();&#10;//            waitlist.setSlotId(slotId);&#10;//            waitlistDAO.addWaitlist(waitlist);&#10;//        }&#10;//&#10;//        if (waitlist.getCustomerIds().contains(customerId)) {&#10;//            return waitlist.getCustomerIds().size();&#10;//        }&#10;//&#10;//        waitlist.getCustomerIds().add(customerId);&#10;//        waitlistDAO.updateWaitlist(waitlist);&#10;//        return waitlist.getCustomerIds().size();&#10;//    }&#10;&#10;    @Override&#10;    public FlipfitBooking addToWaitlist(int customerId, int slotId, LocalDate bookingDate) {&#10;        try {&#10;            FlipfitSlot slot = slotDAO.getSlotById(slotId);&#10;            if (slot == null) {&#10;                throw new SlotNotFoundException(String.valueOf(slotId), &quot;N/A&quot;);&#10;            }&#10;&#10;            FlipfitCustomer customer = customerDAO.getCustomerById(customerId);&#10;            if (customer == null) {&#10;                throw new UserNotFoundException(String.valueOf(customerId), &quot;Customer&quot;);&#10;            }&#10;&#10;            FlipfitWaitlist waitlist = waitlistDAO.getWaitlistBySlotId(slotId);&#10;            if (waitlist == null) {&#10;                waitlist = new FlipfitWaitlist();&#10;                waitlist.setSlotId(slotId);&#10;                boolean created = waitlistDAO.addWaitlist(waitlist);&#10;                if (!created) {&#10;                    throw new DatabaseException(&quot;Failed to create waitlist for slot &quot; + slotId);&#10;                }&#10;            }&#10;&#10;            if (waitlist.getCustomerIds().contains(customerId)) {&#10;                throw new BookingNotConfirmedException(&quot;You are already on the waitlist for this slot.&quot;);&#10;            }&#10;&#10;            waitlist.getCustomerIds().add(customerId);&#10;            boolean updated = waitlistDAO.updateWaitlist(waitlist);&#10;            if (!updated) {&#10;                throw new DatabaseException(&quot;Failed to update waitlist for slot &quot; + slotId);&#10;            }&#10;&#10;            FlipfitBooking waitlistBooking = new FlipfitBooking(0, customerId, slotId, slot.getCenterId(), bookingDate, slot.getPrice());&#10;            waitlistBooking.setStatus(FlipfitBooking.BookingStatus.WAITLISTED);&#10;            boolean bookingAdded = bookingDAO.addBooking(waitlistBooking);&#10;            &#10;            if (!bookingAdded) {&#10;                throw new BookingNotConfirmedException(&quot;Failed to add waitlist booking for slot &quot; + slotId);&#10;            }&#10;&#10;            System.out.println(&quot;Successfully added to waitlist for slot &quot; + slotId + &quot; on &quot; + bookingDate);&#10;            return waitlistBooking;&#10;        } catch (SlotNotFoundException | UserNotFoundException | BookingNotConfirmedException | DatabaseException e) {&#10;            String errorMessage = ExceptionHandler.handleException(e);&#10;            System.err.println(errorMessage);&#10;            return null;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Unexpected error adding to waitlist: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitBooking&gt; viewBookings(int customerId) {&#10;        return bookingDAO.getBookingsByCustomerId(customerId);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitBooking&gt; viewBookingsByDate(int customerId, LocalDate date) {&#10;        return bookingDAO.getBookingsByCustomerId(customerId).stream()&#10;                .filter(booking -&gt; booking.getBookingDate().equals(date))&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    @Override&#10;    public FlipfitCustomer getCustomerProfile(int customerId) {&#10;        return customerDAO.getCustomerById(customerId);&#10;    }&#10;&#10;    @Override&#10;    public boolean updateCustomerProfile(FlipfitCustomer customer) {&#10;        return customerDAO.updateCustomer(customer);&#10;    }&#10;&#10;    @Override&#10;    public boolean addCard(FlipfitCard card) {&#10;        return cardDAO.addCard(card);&#10;    }&#10;&#10;    @Override&#10;    public boolean removeCard(int cardId, int customerId) {&#10;        return cardDAO.removeCard(cardId, customerId);&#10;    }&#10;&#10;    @Override&#10;    public boolean updateCard(FlipfitCard card) {&#10;        return cardDAO.updateCard(card);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;FlipfitCard&gt; getCustomerCards(int customerId) {&#10;        return cardDAO.getCustomerCards(customerId);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>